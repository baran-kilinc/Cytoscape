<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Baran Layout</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.1/cytoscape.min.js"></script>
  <script src="https://unpkg.com/cytoscape-cose-bilkent@4.0.0/cytoscape-cose-bilkent.js"></script>
  <script src="https://unpkg.com/cytoscape-cose-bilkent@4.0.0/cytoscape-cose-bilkent.js"></script>
  <style>
    /* Tüm edge'leri varsayılan olarak gizle */
    .edge-hidden {
      opacity: 0 !important;
      z-index: -1 !important;
    }
    .edge-highlight-l0 { line-color: #e60073 !important; target-arrow-color: #e60073 !important; width: 18px !important; opacity: 1 !important; z-index: 10 !important; }
    .edge-highlight-l1 { line-color: #ff9800 !important; target-arrow-color: #ff9800 !important; width: 14px !important; opacity: 1 !important; z-index: 10 !important; }
    .edge-highlight-l2 { line-color: #ffeb3b !important; target-arrow-color: #ffeb3b !important; width: 10px !important; opacity: 1 !important; z-index: 10 !important; }
    #cy {
      width: 100%;
      height: 600px;
      border: 1px solid black;
      position: relative;
    }
    #magnifier-crosshair {
      position: absolute;
      left: 0; top: 28px;
      width: 100%; height: calc(100% - 28px);
      pointer-events: none;
      z-index: 30;
    }
    #magnifier-crosshair:after, #magnifier-crosshair:before {
      content: "";
      position: absolute;
      background: #3a59e4;
      opacity: 0.7;
    }
    #magnifier-crosshair:after {
      left: 50%; top: 0;
      width: 2px; height: 100%;
      transform: translateX(-1px);
    }
    #magnifier-crosshair:before {
      top: 50%; left: 0;
      width: 100%; height: 2px;
      transform: translateY(-1px);
    }
    #node-data {
      border: 1px solid black;
      padding: 10px;
      margin-top: 10px;
      display: none;
      background: #fafafa;
      max-width: 600px;
      font-family: monospace;
    }
    #exportBtn, #customLayoutBtn {
      position: absolute;
      top: 18px;
      z-index: 10;
      padding: 8px 16px;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
    }
    #exportBtn {
      right: 18px;
      background: #43a047;
    }
    #exportBtn:hover {
      background: #388e3c;
    }
    #customLayoutBtn {
      right: 170px;
      background: #1976d2;
    }
    #customLayoutBtn:hover {
      background: #115293;
    }
    body {
      position: relative;
    }
    .node-search-highlight {
      border-color: #1976d2 !important;
      border-width: 16px !important;
      box-shadow: 0 0 20px #1976d2 !important;
      background-color: #e3f2fd !important;
    }
    .highlight-l0 { background-color: #f52d05 !important; color: #000 !important; }
    .highlight-l1 { background-color: #f57105 !important; color: #000 !important; }
    .highlight-l2 { background-color: #f5c105 !important; color: #000 !important; }
    #context-menu {
      position: absolute;
      display: none;
      background: #fff;
      border: 1px solid #999;
      border-radius: 5px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.15);
      z-index: 100;
      min-width: 120px;
      font-family: sans-serif;
    }
    #context-menu ul { list-style: none; margin: 0; padding: 7px 0 7px 0; }
    #context-menu ul li {
      padding: 7px 20px; cursor: pointer; transition: background 0.2s; font-size: 16px;
    }
    #context-menu ul li:hover { background: #f1f1f1; }
    #fullscreen-panel {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.97);
      z-index: 200;
      box-shadow: 0 2px 16px rgba(0,0,0,0.18);
      animation: fadein 0.2s;
    }
    @keyframes fadein { from { opacity: 0; } to   { opacity: 1; } }
    #fullscreen-content {
      position: absolute;
      top: 40px;
      left: 40px;
      right: 40px;
      bottom: 40px;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 3px 30px rgba(0,0,0,0.15);
      padding: 40px 40px 40px 40px;
      overflow: auto;
      font-size: 22px;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    #fullscreen-close {
      position: absolute;
      top: 16px;
      right: 32px;
      background: #f44336;
      border: none;
      color: #fff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 22px;
      font-weight: bold;
      cursor: pointer;
      z-index: 210;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    #fullscreen-close:hover { background: #c62828; }
    #magnifier-btn {
      position: absolute;
      top: 18px;
      right: 720px;
      z-index: 10;
      background: none;
      border: none;
      cursor: pointer;
      width: 36px;
      height: 36px;
      padding: 0;
    }
    #magnifier-btn.active {
      filter: drop-shadow(0 0 6px #0077ff);
      background: #eef6ff;
      border-radius: 50%;
    }
    #magnifier-panel {
      position: fixed;
      width: 400px;
      height: 300px;
      right: 32px;
      bottom: 62px;
      background: #fff;
      border: 2px solid #aaa;
      z-index: 9999;
      display: none;
      overflow: hidden;
      pointer-events: none;
      box-sizing: border-box;
    }
    #magnifier-cy {
      width: 100%;
      height: 300px;
      display: block;
      background: #fff;
    }
    #magnifier-zoom-bar {
      width: 100%;
      height: 28px;
      box-sizing: border-box;
      margin: 0;
      padding: 0 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f6f6f6;
      border-bottom: 1px solid #ddd;
      position: relative;
      pointer-events: auto;
      user-select: none;
    }
    #magnifier-zoom-bar input[type=range] {
      width: 90px;
      margin: 0 6px;
    }
    #magnifier-zoom-value {
      font-size: 12px;
      color: #333;
      min-width: 40px;
      text-align: left;
    }

    #magnifier-zoom-value {
      font-size: 12px;
      color: #333;
      min-width: 40px;
      text-align: left;
    }
    


        
    /* === YENİ EKLENECEK KOD BAŞLANGICI === */

    /* Üst kontrol panelini hizalamak için */
    #top-controls {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      gap: 15px; /* Elemanlar arasına boşluk koyar */
      background-color: #f5f5f5;
      border-bottom: 1px solid #ddd;
    }

    #top-controls h2 {
      margin: 0;
      font-size: 20px;
    }

    /* Butonları sağa itmek için boşluk elemanı */
    .spacer {
      flex-grow: 1;
    }

    /* Arama kutusu */
    #searchBox {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #ccc;
      font-size: 16px;
      width: 250px;
    }

    /* Vurgulanan düğüm için stil */
    .node-search-highlight {
      background-color: #e3f2fd !important; /* Açık mavi arka plan */
      border-color: #0d47a1 !important; /* Koyu mavi kenarlık */
      border-width: 15px !important;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    #moveMostConnectedBtn {
      position: absolute;
      right: 315px; /* Undo butonu ile aynı konumda */
      top: 18px;
      background: #8e24aa;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      z-index: 10;
    }
    #moveMostConnectedBtn:hover {
      background: #5e2074;
    }






/* Çerçeve toggle butonu - MEVCUT ID İLE GÜNCELLENDİ */
#frameToggleBtn {
  position: absolute;
  right: 550px;
  top: 18px;
  background: #673ab7;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 16px;
  cursor: pointer;
  z-index: 10;
}

#frameToggleBtn:hover {
  background: #512da8;
}



.group-header {
  user-select: none;
  will-change: transform;
}


.sensor-frame {
  border-color: #f44336;
  background-color: #f44336;
}

.ecu-frame {
  border-color: #2196f3;
  background-color: #2196f3;
}

.actuator-frame {
  border-color: #ff9800;
  background-color: #ff9800;
}

/* Cytoscape içindeki çerçeveler için genel stil */
.group-frame {
  border-width: 15px;
  border-style: solid;
  background-opacity: 0; /* Şeffaf arka plan */
  z-index: -1;
  text-valign: top; /* Yazıyı üste hizala */
  text-halign: center; /* Yazıyı ortala */
  font-size: 500px; /* Yazı boyutu büyütüldü */
  font-weight: bold;
  color: white;
  text-outline-width: 3px; /* Kenarlık kalınlaştırıldı */
  text-outline-color: black;
  text-outline-opacity: 0.9; /* Kenarlık netleştirildi */
  text-margin-y: -20px; /* Yazıyı yukarı kaydır (eklendi) */
  shape: rectangle;
  padding: 20px;
}



  </style>
</head>
<body>
  
<!-- Hata paneli -->
<div id="error-panel" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(255,255,255,0.95); z-index:99999;">
  <button id="error-close-btn" style="position:absolute; top:20px; right:30px; background:#f44336; color:#fff; border:none; border-radius:50%; width:40px; height:40px; font-size:22px; cursor:pointer;">&times;</button>
  <div style="position:absolute; top:80px; left:50%; transform:translateX(-50%); max-width:600px; background:#fff; padding:40px 30px 30px 30px; border-radius:12px; box-shadow:0 4px 40px rgba(0,0,0,0.09); font-family:'Segoe UI', Arial;">
    <h2 style="margin-top:0;">Fehlermeldung!</h2>
    <div>
      <textarea id="error-message-area" readonly style="width:100%; height:160px; font-size:16px; padding:10px; resize:vertical; border:1px solid #999; border-radius:8px; background:#f6f6f6; margin-bottom:16px;"></textarea>
      <button id="error-copy-btn" style="background:#1976d2; color:#fff; border:none; border-radius:6px; padding:7px 18px; font-size:16px; cursor:pointer;">Kopieren</button>
    </div>
  </div>
</div>



  <div id="top-controls">
    <h2>The Baran Layout</h2>
    <input type="file" id="jsonFileInput" accept=".json">
    <div id="search-container">
      <input type="text" id="searchBox" placeholder="Suche...">
    </div>
    <div class="spacer"></div> <!-- Bu eleman butonları sağa itecek -->
    <button id="customLayoutBtn">Localisation</button>
    <button id="frameToggleBtn">Rahmen Ein/Aus</button>
    <button id="exportBtn">Export JSON</button>
    <button id="moveMostConnectedBtn">Finde die zentrale Node</button>
    <button id="magnifier-btn" title="Zoom">
      <svg viewBox="0 0 40 40" width="24" height="24" fill="none" stroke="black" stroke-width="2">
        <circle cx="17" cy="17" r="10" stroke-width="2.5"/>
        <line x1="27" y1="27" x2="36" y2="36" stroke-width="3" stroke-linecap="round"/>
      </svg>
    </button>


    
  </div>

  <div id="cy"></div>
  <div id="magnifier-panel">
    <div id="magnifier-zoom-bar">
      <span style="font-size:13px; color:#666;" title="Zoom Faktor">🔍</span>
      <input id="magnifier-zoom-range" type="range" min="1" max="10" step="0.1" value="2">
      <span id="magnifier-zoom-value">2.0x</span>
    </div>
    <div id="magnifier-cy"></div>
    <div id="magnifier-crosshair"></div> <!-- YENİ EKLENDİ -->
  </div>
  <div id="node-data"></div>
  <div id="context-menu">
    <ul>
      <li id="context-more">Mehr</li>
    </ul>
  </div>
  <div id="fullscreen-panel">
    <button id="fullscreen-close">&times;</button>
    <div id="fullscreen-content"></div>
  </div>
  <script>

// Hata panelini gösteren fonksiyon
function showErrorPanel(errorMsg) {
  document.getElementById('error-panel').style.display = 'block';
  document.getElementById('error-message-area').value = errorMsg;
}

// Paneli kapat
document.getElementById('error-close-btn').addEventListener('click', function() {
  document.getElementById('error-panel').style.display = 'none';
});

// Kopyala butonu
document.getElementById('error-copy-btn').addEventListener('click', function() {
  const textarea = document.getElementById('error-message-area');
  textarea.select();
  document.execCommand('copy');
});

// Örnek: Dosya okuma eventine hata yakalama ekle
document.getElementById('jsonFileInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const json = JSON.parse(ev.target.result);
      // Devam: json ile işlemler...
      // eğer burada hata olursa catch'e düşer
    } catch (err) {
      // Hem JS hatası hem de browser'ın verdiği hata mesajı
      showErrorPanel("Hatalı veri: " + err.message);
    }
  };
  reader.onerror = function(ev) {
    // Browser hata mesajı
    showErrorPanel("Dosya okunamadı: " + reader.error.message);
  };
  reader.readAsText(file);
});



// Cytoscape instance oluşturulduktan SONRA bu event listener'ları ekleyin
function setupFrameEventListeners() {
  if (cyInstance) {
    // Önceki event listener'ları temizle
    cyInstance.off('tap');
    
    // Yeni event listener'ları ekle
    cyInstance.on('tap', 'node', function(evt) {
      handleFrameCloseClick(evt);
      // Diğer node tıklama işlemleriniz buraya...
    });
    
    // Layout değişikliklerinde çerçeveleri güncelle
    cyInstance.on('layoutstop', updateGroupFrames);
    
    // Node pozisyon değişikliklerinde çerçeveleri güncelle
    cyInstance.on('position', 'node', function(evt) {
      if (!evt.target.data('isFrame') && !evt.target.data('isFrameClose')) {
        setTimeout(updateGroupFrames, 100);
      }
    });
    
    console.log('Frame event listeners setup complete'); // Debug için
  }
}

// setupFrameEventListeners() fonksiyonunun ALTINA bu fonksiyonu ekleyin
function setupEdgeHighlightEvents() {
  if (!cyInstance) return;
  
  // Node üzerine mouse geldiğinde
  cyInstance.on('mouseover', 'node', function(evt) {
    const node = evt.target;
    
    // Önce tüm edge'lerin highlight'ını kaldır
    cyInstance.edges().removeClass('edge-highlight-l0 edge-highlight-l1 edge-highlight-l2');
    
    // Bu node'a bağlı edge'leri highlight et
    const connectedEdges = node.connectedEdges();
    connectedEdges.forEach(edge => {
      edge.addClass('edge-highlight-l0'); // Direkt bağlantılar için level 0
    });
  });

  // Node'dan mouse çıktığında
  cyInstance.on('mouseout', 'node', function(evt) {
    // Tüm edge highlight'larını kaldır
    cyInstance.edges().removeClass('edge-highlight-l0 edge-highlight-l1 edge-highlight-l2');
  });

  // Node'a tıklandığında (kalıcı highlight için)
  cyInstance.on('tap', 'node', function(evt) {
    const node = evt.target;
    
    // Frame işlemleri için mevcut kodunuz çalışsın
    handleFrameCloseClick(evt);
    
    // Edge highlight işlemleri
    cyInstance.edges().removeClass('edge-highlight-l0 edge-highlight-l1 edge-highlight-l2');
    
    const connectedEdges = node.connectedEdges();
    connectedEdges.forEach(edge => {
      edge.addClass('edge-highlight-l0');
    });
  });

  // Boş alana tıklandığında tüm highlight'ları kaldır
  cyInstance.on('tap', function(evt) {
    if (evt.target === cyInstance) {
      cyInstance.edges().removeClass('edge-highlight-l0 edge-highlight-l1 edge-highlight-l2');
    }
  });
}


      function findMostConnectedNode(cy) {
        let maxDegree = -1;
        let maxNode = null;
        cy.nodes().forEach(node => {
          const degree = node.connectedEdges().length;
          if (degree > maxDegree) {
            maxDegree = degree;
            maxNode = node;
          }
        });
        return maxNode;
      }


    // --- Cytoscape mouse zoom fix ---
    function addCytoscapeMouseZoomFix(cy) {
      let lastMousePos = {x: 0, y: 0};
      cy.container().addEventListener('mousemove', function(e) {
        const rect = cy.container().getBoundingClientRect();
        lastMousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      });
      cy.container().addEventListener('wheel', function(e) {
        if (e.ctrlKey || e.altKey || e.shiftKey || Math.abs(e.deltaX) > 0) return;
        e.preventDefault();
        let zoom = cy.zoom();
        let minZoom = cy.minZoom();
        let maxZoom = cy.maxZoom();
        let zoomFactor = (e.deltaY < 0) ? 0.5 : 2;
        let newZoom = Math.max(minZoom, Math.min(maxZoom, zoom * zoomFactor));
        cy.zoom({
          level: newZoom,
          renderedPosition: lastMousePos
        });
      }, { passive: false });
    }

    // --- The rest of your original code, with call to the zoom fix ---

    let cyInstance = null;
    let lastElements = null;
    let contextNode = null;







    function enrichNodesWithParentData(elements) {
      const nodeMap = {};
      elements.forEach(el => {
        if (!el.data || !el.data.id) return;
        nodeMap[el.data.id] = el.data;
      });
      elements.forEach(el => {
        if (!el.data || !el.data.parent) return;
        const parentId = el.data.parent;
        const parent = nodeMap[parentId];
        if (parent) {
          const parentInfo = {
            id: parent.id,
            label: parent.label,
            type: parent.type || parent.originalType,
            originalType: parent.originalType,
            x: (parent.position && typeof parent.position.x === "number") ? parent.position.x : undefined,
            y: (parent.position && typeof parent.position.y === "number") ? parent.position.y : undefined,
            layout_x: parent.layout_x,
            layout_y: parent.layout_y,
            layout_width: parent.layout_width,
            layout_height: parent.layout_height
          };
          if (typeof parent.componenttype !== "undefined") {
            parentInfo.componenttype = parent.componenttype;
          }
          el.data.parentInfo = parentInfo;
        }
      });
    }

    function getNodeSize(node) {
      const label = node.data('label') || '';
      const lines = countLabelLines(label);
      let w = 300;
      let h = 30 * lines + 40;
      if (typeof node.data('width') === 'number') w = node.data('width');
      if (typeof node.data('height') === 'number') h = node.data('height');
      return { width: w, height: h };
    }

    function parseDriveAssistData(json) {
      const elements = [];
      if (json.elements && Array.isArray(json.elements.nodes)) {
        for (const n of json.elements.nodes) {
          let mappedType = n.data.type;
          if (mappedType === 'allocationtargetfunml') mappedType = 'Bus';
          else if (mappedType === 'logicalclusterfunml') mappedType = 'Cluster';
          else if (mappedType === 'logicalsubcontextfunml') mappedType = 'Subcontext';

          let position = undefined;
          if (typeof n.data.position === "object" && n.data.position !== null && typeof n.data.position.x === "number" && typeof n.data.position.y === "number") {
            position = { x: n.data.position.x, y: n.data.position.y };
          } else if (typeof n.data.x === "number" && typeof n.data.y === "number") {
            position = { x: n.data.x, y: n.data.y };
          }
          const wrappedLabel = wrapLabel(n.data.label, 15);
          const nodeObj = {
            data: {
              ...n.data,
              label: wrappedLabel,
              type: mappedType,
              originalType: n.data.type,
              height: 80 * countLabelLines(wrappedLabel) + 50
            }
          };
          if (position) {
            nodeObj.position = position;
            nodeObj.data.position = position;
          }
          elements.push(nodeObj);
        }
      }
      // EDGES KISMI EKLENDİ
      if (json.elements && Array.isArray(json.elements.edges)) {
        for (const e of json.elements.edges) {
          elements.push({
            data: {
              id: e.data.id || (e.data.source + ':' + e.data.target),
              source: e.data.source,
              target: e.data.target,
              label: e.data.label || '',
              ...e.data
            },
            group: 'edges'
          });
        }
      }
      return elements;
    }

    function hasAnyNodeWithPosition(elements) {
      return elements.some(el => el.position && typeof el.position.x === "number" && typeof el.position.y === "number");
    }




// Label'a göre node genişliği ölçüm fonksiyonu
function computeNodeWidthByLabel(label, font = "18px Arial", minWidth = 100, padding = 40) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = font;
  const textWidth = ctx.measureText(label).width;
  return Math.max(minWidth, textWidth + padding);
}


function wrapLabel(label, maxLen = 15) {
  if (typeof label !== 'string') return label;
  if (label.length <= maxLen) return label;
  let result = '';
  for (let i = 0; i < label.length; i += maxLen) {
    result += label.substr(i, maxLen);
    if (i + maxLen < label.length) result += '\n';
  }
  return result;
}

function countLabelLines(label) {
  if (typeof label !== 'string') return 1;
  return label.split('\n').length;
}











// ---- YENİ CUSTOM LAYOUT ALGORITHM (çakışmasız ve ortalanmış) ----
// ---- YENİ CUSTOM LAYOUT ALGORITHM (çakışmasız ve ortalanmış) ----
function applyCustomLayoutForAllocationTargets(cy) {
  // CHILD_PADDING ve VERTICAL_CHILD_PADDING iki katına çıkarıldı!
  const CHILD_PADDING = 450; // Child node'lar arası boşluk (2 kat)
  const CHILD_SIDE_PADDING = 150; // Parent-child kenar boşlukları (child'lar arası dikeyde de kullanılacak)
  const VERTICAL_CHILD_PADDING = 50; // Sensor/Actuator child'ları arası dikey boşluk (2 kat)
  const CHILD_SIDE_PADDING_SENSOR = 250;
  const CHILD_SIDE_PADDING_ACTUATOR = 250;

  function getNodeSize(n) {
    const label = n.data('label') || '';
    const lines = countLabelLines(label);
    const font = "18px Arial";
    const width = computeNodeWidthByLabel(label, font, 100, 40);
    const height = 40 * lines + 40; // Satır sayısına göre dinamik yükseklik
    return { width, height };
  }

  function calcTotalSize(nodes, axis) {
    if (nodes.length === 0) return 0;
    let total = 0;
    nodes.forEach(n => {
      const size = getNodeSize(n);
      total += axis === "x" ? size.width : size.height;
    });
    total += (nodes.length - 1) * (axis === "x" ? CHILD_PADDING : VERTICAL_CHILD_PADDING);
    return total;
  }

  const parentNodes = cy.nodes().filter(n =>
    n.data('originalType') === "allocationtargetfunml" &&
    typeof n.data('componenttype') !== "undefined"
  );

  function getChildNodesOfParent(parentId) {
    return cy.nodes().filter(n =>
      n.data('parent') === parentId
    );
  }

  // --- ECU & ZUSAMMENBAU GRUPLARI (MERKEZ - X=0) ---
  (function localizeAndPlaceUnlocalisedNodes() {
    // --- Padding ve boşluk parametreleri ---
    const TARGET_TYPES = new Set(["ECU", "Zusammenbau"]);
    const VERTICAL_GROUP_GAP = 400;
    const CHILD_PADDING = 750; // Child node'lar arası yatay boşluk
    const VERTICAL_CHILD_PADDING = 250; // Child node'lar arası dikey boşluk
    const ECU_CHILD_OFFSET_Y = 100; // Parent'ın altında child grid'in başlangıç mesafesi

    // Grid satır kuralları - child sayısına göre satır düzeni
    function getGridLayout(childCount) {
      if (childCount <= 2) {
        return [childCount]; // Tek satır
      } else if (childCount === 3) {
        return [2, 2, 1]; // 3-2  
      } else if (childCount === 4) {
        return [2, 2]; // 2-2
      } else if (childCount === 5) {
        return [3, 2]; // 3-2
      } else if (childCount === 6) {
        return [2, 2, 2]; // 2-2-2
      } else if (childCount === 7) {
        return [4, 3]; // 4-3
      } else if (childCount === 8) {
        return [4, 4]; // 4-4
      } else if (childCount === 9) {
        return [4, 4, 1]; // 4-4-1
      } else if (childCount === 10) {
        return [4, 4, 2]; // 4-4-2
      } else if (childCount === 11) {
        return [4, 4, 3]; // 4-4-3
      } else if (childCount === 12) {
        return [4, 4, 4]; // 4-4-4
      } else if (childCount === 13) {
        return [4, 4, 4, 1]; // 4-4-4-1
      } else if (childCount === 14) {
        return [4, 4, 4, 2]; // 4-4-4-2
      } else if (childCount === 15) {
        return [4, 4, 4, 3]; // 4-4-4-3
      } else if (childCount === 16) {
        return [4, 4, 4, 4]; // 4-4-4-4
      } else if (childCount === 17) {
        return [4, 4, 4, 4, 1]; // 4-4-4-4-1
      } else if (childCount === 18) {
        return [4, 4, 4, 4, 2]; // 4-4-4-4-2
      } else if (childCount === 19) {
        return [4, 4, 4, 4, 3]; // 4-4-4-4-3
      } else if (childCount === 20) {
        return [4, 4, 4, 4, 4]; // 4-4-4-4-4
      } else {
        // 20'den fazla için 4'lü satırlar devam eder
        const fullRows = Math.floor(childCount / 4);
        const remainder = childCount % 4;
        const layout = Array(fullRows).fill(4);
        if (remainder > 0) layout.push(remainder);
        return layout;
      }
    }

    // --- ECU & Zusammenbau gruplarını hizala ---
    const targetParents = parentNodes.filter(p => TARGET_TYPES.has(p.data('componenttype')));
    if (targetParents.length === 0) return;

    // Child sayısına göre sırala (çoktan aza)
    const sortedParents = targetParents.sort((a, b) =>
      getChildNodesOfParent(b.id()).length - getChildNodesOfParent(a.id()).length
    );

    // Parent'ları grupla: 7+ child olanlar tek başına, 6 ve altı olanlar ikişer ikişer
    const parentRows = [];
    let currentRow = [];
    
    sortedParents.forEach(parent => {
      const childCount = getChildNodesOfParent(parent.id()).length;
      
      if (childCount >= 7) {
        // 7+ child olan parent'lar tek başına bir satırda
        if (currentRow.length > 0) {
          parentRows.push([...currentRow]);
          currentRow = [];
        }
        parentRows.push([parent]);
      } else {
        // 6 ve altı child olan parent'lar ikişer ikişer
        currentRow.push(parent);
        if (currentRow.length === 2) {
          parentRows.push([...currentRow]);
          currentRow = [];
        }
      }
    });
    
    // Son satırda kalan parent'ları ekle
    if (currentRow.length > 0) {
      parentRows.push(currentRow);
    }

    let currentY = 0;
    const ROW_GAP = 800; // Satırlar arası mesafe
    const PARENT_HORIZONTAL_GAP = 700; // Aynı satırdaki parent'lar arası yatay mesafe

    parentRows.forEach(rowParents => {
      // Bu satırdaki tüm parent'ların toplam genişliğini ve yüksekliğini hesapla
      let maxRowHeight = 0;
      const parentData = rowParents.map(parent => {
        const parentSize = getNodeSize(parent);
        const children = getChildNodesOfParent(parent.id());
        const gridLayout = getGridLayout(children.length);
        
        // Child grid boyutlarını hesapla
        let maxChildWidth = 0;
        let maxChildHeight = 0;
        children.forEach(child => {
          const childSize = getNodeSize(child);
          if (childSize.width > maxChildWidth) maxChildWidth = childSize.width;
          if (childSize.height > maxChildHeight) maxChildHeight = childSize.height;
        });
        
        // Grid'in toplam genişliği (en geniş satırdaki child sayısına göre)
        const maxRowWidth = Math.max(...gridLayout);
        const gridWidth = maxRowWidth * maxChildWidth + (maxRowWidth - 1) * CHILD_PADDING;
        
        // Grid'in toplam yüksekliği
        const gridHeight = gridLayout.length * maxChildHeight + (gridLayout.length - 1) * VERTICAL_CHILD_PADDING;
        
        // Parent + child grid'in toplam yüksekliği
        const totalHeight = parentSize.height + ECU_CHILD_OFFSET_Y + gridHeight;
        if (totalHeight > maxRowHeight) maxRowHeight = totalHeight;
        
        return {
          parent,
          parentSize,
          children,
          gridLayout,
          maxChildWidth,
          maxChildHeight,
          gridWidth,
          gridHeight,
          totalWidth: Math.max(parentSize.width, gridWidth)
        };
      });

      // Bu satırdaki parent'ların toplam genişliği
      const totalRowWidth = parentData.reduce((sum, data, index) => 
        sum + data.totalWidth + (index > 0 ? PARENT_HORIZONTAL_GAP : 0), 0
      );

      // Parent'ları x=0 merkezli olarak yerleştir
      let startX = -totalRowWidth / 2;

      parentData.forEach((data, index) => {
        const { parent, parentSize, children, gridLayout, maxChildWidth, maxChildHeight, gridWidth, totalWidth } = data;
        
        // Parent'ın x pozisyonu (kendi alanının ortasında)
        const parentX = startX + totalWidth / 2;
        const parentY = currentY + parentSize.height / 2;
        
        // Parent'ı konumlandır
        parent.position({ x: parentX, y: parentY });

        // Child'ları grid düzeninde konumlandır
        if (children.length > 0) {
          let childIndex = 0;
          const gridStartX = parentX - gridWidth / 2;
          const gridStartY = parentY + parentSize.height / 2 + ECU_CHILD_OFFSET_Y;

          gridLayout.forEach((rowChildCount, rowIndex) => {
            // Bu satırdaki child'ların toplam genişliği
            const rowWidth = rowChildCount * maxChildWidth + (rowChildCount - 1) * CHILD_PADDING;
            // Bu satırın başlangıç x'i (ortalanmış)
            const rowStartX = gridStartX + (gridWidth - rowWidth) / 2;
            
            for (let colIndex = 0; colIndex < rowChildCount; colIndex++) {
              if (childIndex < children.length) {
                const child = children[childIndex];
                const childX = rowStartX + colIndex * (maxChildWidth + CHILD_PADDING) + maxChildWidth / 2;
                const childY = gridStartY + rowIndex * (maxChildHeight + VERTICAL_CHILD_PADDING) + maxChildHeight / 2;
                
                child.position({ x: childX, y: childY });
                childIndex++;
              }
            }
          });
        }

        startX += totalWidth + PARENT_HORIZONTAL_GAP;
      });

      currentY += maxRowHeight + ROW_GAP;
    });

    // --- Diğer parent grupları ve nodeleri yerleştir ---
    const parentNodeses = cy.nodes().filter(n =>
      n.data('originalType') === "allocationtargetfunml" &&
      (
        n.data('componenttype') === "ECU" ||
        n.data('componenttype') === "Sensor" ||
        n.data('componenttype') === "Actuator" ||
        n.data('componenttype') === "Zusammenbau"
      )
    );
    const localisedParentIds = new Set(parentNodeses.map(n => n.id()));
    const localisedChildIds = new Set();
    parentNodeses.forEach(parent => {
      cy.nodes().forEach(n => {
        if (n.data('parent') === parent.id()) localisedChildIds.add(n.id());
      });
    });
    const excludedIds = new Set([...localisedParentIds, ...localisedChildIds]);
    const unlocalisedNodes = cy.nodes().filter(n => !excludedIds.has(n.id()));

    if (unlocalisedNodes.length > 0) {
      // En alt noktadan başlayarak diğer node'ları yerleştir
      const startY = currentY + 750;

      // 1. Parent'lı ve parent'sız nodeleri ayır
      const parentGroups = [];
      const singles = [];
      const unlocalisedParents = unlocalisedNodes.filter(n => getChildNodesOfParent(n.id()).length > 0);
      const usedNodeIds = new Set();
      unlocalisedParents.forEach(parent => {
        const children = getChildNodesOfParent(parent.id()).filter(n => unlocalisedNodes.some(un => un.id() === n.id()));
        parentGroups.push({ parent, children });
        usedNodeIds.add(parent.id());
        children.forEach(n => usedNodeIds.add(n.id()));
      });
      unlocalisedNodes.forEach(n => {
        if (!usedNodeIds.has(n.id())) {
          singles.push(n);
        }
      });

      // 2. Grupların toplam genişliğini ve başlama noktasını hesapla
      let totalGroupsWidth = 0;
      const groupWidths = [];
      parentGroups.forEach(({ parent, children }, i) => {
        const parentSize = getNodeSize(parent);
        const childrenWidth = children.reduce((sum, n, idx) => {
          const size = getNodeSize(n);
          return sum + size.width + (idx > 0 ? CHILD_PADDING : 0);
        }, 0);
        const groupWidth = Math.max(parentSize.width, childrenWidth);
        groupWidths.push(groupWidth);
        totalGroupsWidth += groupWidth;
        if (i > 0) totalGroupsWidth += CHILD_PADDING;
      });

      let startX = -totalGroupsWidth / 2;

      parentGroups.forEach(({ parent, children }, i) => {
        const parentSize = getNodeSize(parent);
        const childrenWidth = children.reduce((sum, n, idx) => {
          const size = getNodeSize(n);
          return sum + size.width + (idx > 0 ? CHILD_PADDING : 0);
        }, 0);
        const groupWidth = groupWidths[i];

        // Parent'i ortala
        parent.position({
          x: startX + groupWidth / 2,
          y: startY - parentSize.height / 2 - CHILD_SIDE_PADDING
        });

        // Child'ları parent'in altına, yan yana ortala
        let childStartX = startX + groupWidth / 2 - childrenWidth / 2;
        const childY = startY + parentSize.height / 2 + CHILD_SIDE_PADDING;
        children.forEach((n, idx) => {
          const size = getNodeSize(n);
          n.position({
            x: childStartX + size.width / 2,
            y: childY
          });
          childStartX += size.width + CHILD_PADDING;
        });

        startX += groupWidth + CHILD_PADDING;
      });

      // 3. Parent'i olmayan nodeleri EN SAĞA hizala
      let singlesStartX = startX;
      singles.forEach((node, i) => {
        const size = getNodeSize(node);
        node.position({
          x: singlesStartX + size.width / 2 + 200,
          y: startY
        });
        singlesStartX += size.width + 500;
      });
    }
  })();

  // --- SENSOR GRUPLARI (SOL - X=-13000) ---
  (function localizeSensorNodes() {
    // --- Padding ve boşluk parametreleri ---
    const TARGET_TYPES = new Set(["Sensor"]);
    const VERTICAL_GROUP_GAP = 400;
    const CHILD_PADDING = 750; // Child node'lar arası yatay boşluk
    const VERTICAL_CHILD_PADDING = 250; // Child node'lar arası dikey boşluk
    const SENSOR_CHILD_OFFSET_Y = 100; // Parent'ın altında child grid'in başlangıç mesafesi
    const SENSOR_START_X = -13000; // Sensor gruplarının başlangıç noktası

    // İlk çalıştırma flag'i
    if (typeof window.firstSensorLayoutRun === "undefined") {
      window.firstSensorLayoutRun = true;
    }

    // Grid satır kuralları - child sayısına göre satır düzeni
    function getGridLayout(childCount) {
      if (childCount <= 2) {
        return [childCount]; // Tek satır
      } else if (childCount === 3) {
        return [2, 2, 1]; // 3-2  
      } else if (childCount === 4) {
        return [2, 2]; // 2-2
      } else if (childCount === 5) {
        return [3, 2]; // 3-2
      } else if (childCount === 6) {
        return [2, 2, 2]; // 2-2-2
      } else if (childCount === 7) {
        return [4, 3]; // 4-3
      } else if (childCount === 8) {
        return [4, 4]; // 4-4
      } else if (childCount === 9) {
        return [4, 4, 1]; // 4-4-1
      } else if (childCount === 10) {
        return [4, 4, 2]; // 4-4-2
      } else if (childCount === 11) {
        return [4, 4, 3]; // 4-4-3
      } else if (childCount === 12) {
        return [4, 4, 4]; // 4-4-4
      } else if (childCount === 13) {
        return [4, 4, 4, 1]; // 4-4-4-1
      } else if (childCount === 14) {
        return [4, 4, 4, 2]; // 4-4-4-2
      } else if (childCount === 15) {
        return [4, 4, 4, 3]; // 4-4-4-3
      } else if (childCount === 16) {
        return [4, 4, 4, 4]; // 4-4-4-4
      } else if (childCount === 17) {
        return [4, 4, 4, 4, 1]; // 4-4-4-4-1
      } else if (childCount === 18) {
        return [4, 4, 4, 4, 2]; // 4-4-4-4-2
      } else if (childCount === 19) {
        return [4, 4, 4, 4, 3]; // 4-4-4-4-3
      } else if (childCount === 20) {
        return [4, 4, 4, 4, 4]; // 4-4-4-4-4
      } else {
        // 20'den fazla için 4'lü satırlar devam eder
        const fullRows = Math.floor(childCount / 4);
        const remainder = childCount % 4;
        const layout = Array(fullRows).fill(4);
        if (remainder > 0) layout.push(remainder);
        return layout;
      }
    }

    // --- Sensor gruplarını hizala ---
    const targetParents = parentNodes.filter(p => TARGET_TYPES.has(p.data('componenttype')));
    if (targetParents.length === 0) return;

    // Child sayısına göre sırala (çoktan aza)
    const sortedParents = targetParents.sort((a, b) =>
      getChildNodesOfParent(b.id()).length - getChildNodesOfParent(a.id()).length
    );

    // Parent'ları grupla: 7+ child olanlar tek başına, 6 ve altı olanlar ikişer ikişer
    const parentRows = [];
    let currentRow = [];
    
    sortedParents.forEach(parent => {
      const childCount = getChildNodesOfParent(parent.id()).length;
      
      if (childCount >= 7) {
        // 7+ child olan parent'lar tek başına bir satırda
        if (currentRow.length > 0) {
          parentRows.push([...currentRow]);
          currentRow = [];
        }
        parentRows.push([parent]);
      } else {
        // 6 ve altı child olan parent'lar ikişer ikişer
        currentRow.push(parent);
        if (currentRow.length === 2) {
          parentRows.push([...currentRow]);
          currentRow = [];
        }
      }
    });
    
    // Son satırda kalan parent'ları ekle
    if (currentRow.length > 0) {
      parentRows.push(currentRow);
    }

    let currentY = 0;
    const ROW_GAP = 800; // Satırlar arası mesafe
    const PARENT_HORIZONTAL_GAP = 700; // Aynı satırdaki parent'lar arası yatay mesafe

    parentRows.forEach(rowParents => {
      // Bu satırdaki tüm parent'ların toplam genişliğini ve yüksekliğini hesapla
      let maxRowHeight = 0;
      const parentData = rowParents.map(parent => {
        const parentSize = getNodeSize(parent);
        const children = getChildNodesOfParent(parent.id());
        const gridLayout = getGridLayout(children.length);
        
        // Child grid boyutlarını hesapla
        let maxChildWidth = 0;
        let maxChildHeight = 0;
        children.forEach(child => {
          const childSize = getNodeSize(child);
          if (childSize.width > maxChildWidth) maxChildWidth = childSize.width;
          if (childSize.height > maxChildHeight) maxChildHeight = childSize.height;
        });
        
        // Grid'in toplam genişliği (en geniş satırdaki child sayısına göre)
        const maxRowWidth = Math.max(...gridLayout);
        const gridWidth = maxRowWidth * maxChildWidth + (maxRowWidth - 1) * CHILD_PADDING;
        
        // Grid'in toplam yüksekliği
        const gridHeight = gridLayout.length * maxChildHeight + (gridLayout.length - 1) * VERTICAL_CHILD_PADDING;
        
        // Parent + child grid'in toplam yüksekliği
        const totalHeight = parentSize.height + SENSOR_CHILD_OFFSET_Y + gridHeight;
        if (totalHeight > maxRowHeight) maxRowHeight = totalHeight;
        
        return {
          parent,
          parentSize,
          children,
          gridLayout,
          maxChildWidth,
          maxChildHeight,
          gridWidth,
          gridHeight,
          totalWidth: Math.max(parentSize.width, gridWidth)
        };
      });

      // Bu satırdaki parent'ların toplam genişliği
      const totalRowWidth = parentData.reduce((sum, data, index) => 
        sum + data.totalWidth + (index > 0 ? PARENT_HORIZONTAL_GAP : 0), 0
      );

      // Parent'ları SENSOR_START_X'ten başlayarak yerleştir
      let startX = SENSOR_START_X;

      parentData.forEach((data, index) => {
        const { parent, parentSize, children, gridLayout, maxChildWidth, maxChildHeight, gridWidth, totalWidth } = data;
        
        // Parent'ın x pozisyonu (kendi alanının ortasında)
        const parentX = startX + totalWidth / 2;
        const parentY = currentY + parentSize.height / 2;
        
        // Parent'ı konumlandır
        parent.position({ x: parentX, y: parentY });

        // Child'ları grid düzeninde konumlandır
        if (children.length > 0) {
          let childIndex = 0;
          const gridStartX = parentX - gridWidth / 2;
          const gridStartY = parentY + parentSize.height / 2 + SENSOR_CHILD_OFFSET_Y;

          gridLayout.forEach((rowChildCount, rowIndex) => {
            // Bu satırdaki child'ların toplam genişliği
            const rowWidth = rowChildCount * maxChildWidth + (rowChildCount - 1) * CHILD_PADDING;
            // Bu satırın başlangıç x'i (ortalanmış)
            const rowStartX = gridStartX + (gridWidth - rowWidth) / 2;
            
            for (let colIndex = 0; colIndex < rowChildCount; colIndex++) {
              if (childIndex < children.length) {
                const child = children[childIndex];
                const childX = rowStartX + colIndex * (maxChildWidth + CHILD_PADDING) + maxChildWidth / 2;
                const childY = gridStartY + rowIndex * (maxChildHeight + VERTICAL_CHILD_PADDING) + maxChildHeight / 2;
                
                // SADECE İLK ÇALIŞTIRMADA X DEĞERİNİ 0'A ÇEK
                if (window.firstSensorLayoutRun) {
                  child.position({ x: 0, y: childY });
                } else {
                  child.position({ x: childX, y: childY });
                }
                childIndex++;
              }
            }
          });
        }

        startX += totalWidth + PARENT_HORIZONTAL_GAP;
      });

      currentY += maxRowHeight + ROW_GAP;
    });

    // İlk çalıştırmadan sonra flag'i false yap
    window.firstSensorLayoutRun = false;
  })();

  // --- ACTUATOR GRUPLARI (SAĞ - X=+10000) ---
  (function localizeActuatorNodes() {
    // --- Padding ve boşluk parametreleri ---
    const TARGET_TYPES = new Set(["Actuator"]);
    const VERTICAL_GROUP_GAP = 400;
    const CHILD_PADDING = 750; // Child node'lar arası yatay boşluk
    const VERTICAL_CHILD_PADDING = 250; // Child node'lar arası dikey boşluk
    const ACTUATOR_CHILD_OFFSET_Y = 100; // Parent'ın altında child grid'in başlangıç mesafesi
    const ACTUATOR_START_X = 10000; // Actuator gruplarının başlangıç noktası

    // İlk çalıştırma flag'i
    if (typeof window.firstActuatorLayoutRun === "undefined") {
      window.firstActuatorLayoutRun = true;
    }

    // Grid satır kuralları - child sayısına göre satır düzeni
    function getGridLayout(childCount) {
      if (childCount <= 2) {
        return [childCount]; // Tek satır
      } else if (childCount === 3) {
        return [2, 2, 1]; // 3-2  
      } else if (childCount === 4) {
        return [2, 2]; // 2-2
      } else if (childCount === 5) {
        return [3, 2]; // 3-2
      } else if (childCount === 6) {
        return [2, 2, 2]; // 2-2-2
      } else if (childCount === 7) {
        return [4, 3]; // 4-3
      } else if (childCount === 8) {
        return [4, 4]; // 4-4
      } else if (childCount === 9) {
        return [4, 4, 1]; // 4-4-1
      } else if (childCount === 10) {
        return [4, 4, 2]; // 4-4-2
      } else if (childCount === 11) {
        return [4, 4, 3]; // 4-4-3
      } else if (childCount === 12) {
        return [4, 4, 4]; // 4-4-4
      } else if (childCount === 13) {
        return [4, 4, 4, 1]; // 4-4-4-1
      } else if (childCount === 14) {
        return [4, 4, 4, 2]; // 4-4-4-2
      } else if (childCount === 15) {
        return [4, 4, 4, 3]; // 4-4-4-3
      } else if (childCount === 16) {
        return [4, 4, 4, 4]; // 4-4-4-4
      } else if (childCount === 17) {
        return [4, 4, 4, 4, 1]; // 4-4-4-4-1
      } else if (childCount === 18) {
        return [4, 4, 4, 4, 2]; // 4-4-4-4-2
      } else if (childCount === 19) {
        return [4, 4, 4, 4, 3]; // 4-4-4-4-3
      } else if (childCount === 20) {
        return [4, 4, 4, 4, 4]; // 4-4-4-4-4
      } else {
        // 20'den fazla için 4'lü satırlar devam eder
        const fullRows = Math.floor(childCount / 4);
        const remainder = childCount % 4;
        const layout = Array(fullRows).fill(4);
        if (remainder > 0) layout.push(remainder);
        return layout;
      }
    }

    // --- Actuator gruplarını hizala ---
    const targetParents = parentNodes.filter(p => TARGET_TYPES.has(p.data('componenttype')));
    if (targetParents.length === 0) return;

    // Child sayısına göre sırala (çoktan aza)
    const sortedParents = targetParents.sort((a, b) =>
      getChildNodesOfParent(b.id()).length - getChildNodesOfParent(a.id()).length
    );

    // Parent'ları grupla: 7+ child olanlar tek başına, 6 ve altı olanlar ikişer ikişer
    const parentRows = [];
    let currentRow = [];
    
    sortedParents.forEach(parent => {
      const childCount = getChildNodesOfParent(parent.id()).length;
      
      if (childCount >= 7) {
        // 7+ child olan parent'lar tek başına bir satırda
        if (currentRow.length > 0) {
          parentRows.push([...currentRow]);
          currentRow = [];
        }
        parentRows.push([parent]);
      } else {
        // 6 ve altı child olan parent'lar ikişer ikişer
        currentRow.push(parent);
        if (currentRow.length === 2) {
          parentRows.push([...currentRow]);
          currentRow = [];
        }
      }
    });
    
    // Son satırda kalan parent'ları ekle
    if (currentRow.length > 0) {
      parentRows.push(currentRow);
    }

    let currentY = 0;
    const ROW_GAP = 800; // Satırlar arası mesafe
    const PARENT_HORIZONTAL_GAP = 700; // Aynı satırdaki parent'lar arası yatay mesafe

    parentRows.forEach(rowParents => {
      // Bu satırdaki tüm parent'ların toplam genişliğini ve yüksekliğini hesapla
      let maxRowHeight = 0;
      const parentData = rowParents.map(parent => {
        const parentSize = getNodeSize(parent);
        const children = getChildNodesOfParent(parent.id());
        const gridLayout = getGridLayout(children.length);
        
        // Child grid boyutlarını hesapla
        let maxChildWidth = 0;
        let maxChildHeight = 0;
        children.forEach(child => {
          const childSize = getNodeSize(child);
          if (childSize.width > maxChildWidth) maxChildWidth = childSize.width;
          if (childSize.height > maxChildHeight) maxChildHeight = childSize.height;
        });
        
        // Grid'in toplam genişliği (en geniş satırdaki child sayısına göre)
        const maxRowWidth = Math.max(...gridLayout);
        const gridWidth = maxRowWidth * maxChildWidth + (maxRowWidth - 1) * CHILD_PADDING;
        
        // Grid'in toplam yüksekliği
        const gridHeight = gridLayout.length * maxChildHeight + (gridLayout.length - 1) * VERTICAL_CHILD_PADDING;
        
        // Parent + child grid'in toplam yüksekliği
        const totalHeight = parentSize.height + ACTUATOR_CHILD_OFFSET_Y + gridHeight;
        if (totalHeight > maxRowHeight) maxRowHeight = totalHeight;
        
        return {
          parent,
          parentSize,
          children,
          gridLayout,
          maxChildWidth,
          maxChildHeight,
          gridWidth,
          gridHeight,
          totalWidth: Math.max(parentSize.width, gridWidth)
        };
      });

      // Bu satırdaki parent'ların toplam genişliği
      const totalRowWidth = parentData.reduce((sum, data, index) => 
        sum + data.totalWidth + (index > 0 ? PARENT_HORIZONTAL_GAP : 0), 0
      );

      // Parent'ları ACTUATOR_START_X'ten başlayarak yerleştir
      let startX = ACTUATOR_START_X;

      parentData.forEach((data, index) => {
        const { parent, parentSize, children, gridLayout, maxChildWidth, maxChildHeight, gridWidth, totalWidth } = data;
        
        // Parent'ın x pozisyonu (kendi alanının ortasında)
        const parentX = startX + totalWidth / 2;
        const parentY = currentY + parentSize.height / 2;
        
        // Parent'ı konumlandır
        parent.position({ x: parentX, y: parentY });

        // Child'ları grid düzeninde konumlandır
        if (children.length > 0) {
          let childIndex = 0;
          const gridStartX = parentX - gridWidth / 2;
          const gridStartY = parentY + parentSize.height / 2 + ACTUATOR_CHILD_OFFSET_Y;

          gridLayout.forEach((rowChildCount, rowIndex) => {
            // Bu satırdaki child'ların toplam genişliği
            const rowWidth = rowChildCount * maxChildWidth + (rowChildCount - 1) * CHILD_PADDING;
            // Bu satırın başlangıç x'i (ortalanmış)
            const rowStartX = gridStartX + (gridWidth - rowWidth) / 2;
            
            for (let colIndex = 0; colIndex < rowChildCount; colIndex++) {
              if (childIndex < children.length) {
                const child = children[childIndex];
                const childX = rowStartX + colIndex * (maxChildWidth + CHILD_PADDING) + maxChildWidth / 2;
                const childY = gridStartY + rowIndex * (maxChildHeight + VERTICAL_CHILD_PADDING) + maxChildHeight / 2;
                
                // SADECE İLK ÇALIŞTIRMADA X DEĞERİNİ 0'A ÇEK
                if (window.firstActuatorLayoutRun) {
                  child.position({ x: 0, y: childY });
                } else {
                  child.position({ x: childX, y: childY });
                }
                childIndex++;
              }
            }
          });
        }

        startX += totalWidth + PARENT_HORIZONTAL_GAP;
      });

      currentY += maxRowHeight + ROW_GAP;
    });

    // İlk çalıştırmadan sonra flag'i false yap
    window.firstActuatorLayoutRun = false;
  })();

  // --- Diğer parent'lar için child node'ları hizala ---
  parentNodes.forEach(parent => {
    const type = parent.data('componenttype');
    if (type === "Sensor" || type === "Actuator" || type === "ECU" || type === "Zusammenbau") {
      // Bu tipler yukarıda özel sırada işlendi!
      return;
    }
    const childNodes = getChildNodesOfParent(parent.id());
    if (childNodes.length === 0) return;

    // Parent'in EN GÜNCEL pozisyonunu al!
    const px = parent.position('x');
    const py = parent.position('y');
  });
}
















// --- Parent bilgisini her zaman güncel tutmak için: node data'larını tekrar güncelle
function updateNodesWithParentDataLive(cyInstance) {
  if (!cyInstance) return;
  const nodeMap = {};
  cyInstance.nodes().forEach(n => nodeMap[n.id()] = n.data());
  cyInstance.nodes().forEach(n => {
    if (n.data('parent')) {
      const parent = nodeMap[n.data('parent')];
      if (parent) {
        const parentInfo = {
          id: parent.id,
          label: parent.label,
          type: parent.type || parent.originalType,
          originalType: parent.originalType,
          x: (parent.position && typeof parent.position.x === "number") ? parent.position.x : undefined,
          y: (parent.position && typeof parent.position.y === "number") ? parent.position.y : undefined,
          layout_x: parent.layout_x,
          layout_y: parent.layout_y,
          layout_width: parent.layout_width,
          layout_height: parent.layout_height
        };
        if (typeof parent.componenttype !== "undefined") {
          parentInfo.componenttype = parent.componenttype;
        }
        n.data('parentInfo', parentInfo);
      }
    }
  });
}


    // --- Magnifier Integration ---
    let magCy = null;
    const MAG_WIDTH = 400, MAG_HEIGHT = 300;
    let magZoom = 2;
    const magnifierBtn = document.getElementById('magnifier-btn');
    const magnifierPanel = document.getElementById('magnifier-panel');
    const magnifierCyDiv = document.getElementById('magnifier-cy');
    const magnifierZoomRange = document.getElementById('magnifier-zoom-range');
    const magnifierZoomValue = document.getElementById('magnifier-zoom-value');
    let magnifierActive = false;
    const plusCursor = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><circle cx="16" cy="16" r="13" fill="white" stroke="black" stroke-width="2"/><line x1="16" y1="7" x2="16" y2="25" stroke="black" stroke-width="3"/><line x1="7" y1="16" x2="25" y2="16" stroke="black" stroke-width="3"/></svg>';

    function ensureMagCy() {
      if (!cyInstance) return;
      if (magCy) return;
      magCy = cytoscape({
        container: magnifierCyDiv,
        elements: cyInstance.json().elements,
        style: cyInstance.style().json(),
        layout: { name: 'preset' },
        userPanningEnabled: false,
        userZoomingEnabled: false,
        boxSelectionEnabled: false,
        autoungrabify: true,
        autounselectify: true,
        minZoom: 0.1,
        maxZoom: 100
      });
      magCy.on('tap', e => false);
    }

    function syncMagCyElementsAndStyle() {
      if (!magCy || !cyInstance) return;
      magCy.json({ elements: cyInstance.json().elements });
      magCy.style().fromJson(cyInstance.style().json());
      magCy.resize();
    }

    function updateMagnifierView(mouseX, mouseY) {
      if (!magnifierActive) return;
      if (!cyInstance) return;
      ensureMagCy();

      const cyRect = cyInstance.container().getBoundingClientRect();
      const localX = mouseX - cyRect.left + 10;
      const localY = mouseY - cyRect.top + 65;
      const cyGraphPosition = cyInstance.renderer().projectIntoViewport(localX, localY);

      magCy.zoom(cyInstance.zoom() * magZoom);
      magCy.resize();

      const panelWidth = MAG_WIDTH;
      const panelHeight = MAG_HEIGHT;
      const magCenterRendered = { x: panelWidth / 2, y: panelHeight / 2 };
      const panX = magCenterRendered.x - cyGraphPosition[0] * magCy.zoom();
      const panY = magCenterRendered.y - cyGraphPosition[1] * magCy.zoom();
      magCy.pan({ x: panX, y: panY });
      magCy.resize();
    }

    function attachMagnifierEvents() {
      if (!cyInstance) return;
      cyInstance.on('add remove data style', () => {
        if (magnifierActive) {
          ensureMagCy();
          syncMagCyElementsAndStyle();
        }
      });

      magnifierBtn.addEventListener('click', () => {
        magnifierActive = !magnifierActive;
        magnifierBtn.classList.toggle('active', magnifierActive);
        magnifierPanel.style.display = magnifierActive ? 'block' : 'none';
        if (cyInstance && cyInstance.container())
          cyInstance.container().style.cursor = magnifierActive ? `url('${plusCursor}') 16 16, crosshair` : '';
        if (magnifierActive) {
          ensureMagCy();
          syncMagCyElementsAndStyle();
          magCy.resize();
        }
      });

      function onMouseMove(e) {
        if (!magnifierActive) return;
        window.lastMouse = {x: e.clientX, y: e.clientY};
        updateMagnifierView(e.clientX, e.clientY);
      }
      if (cyInstance && cyInstance.container()) {
        cyInstance.container().addEventListener('mousemove', onMouseMove);
        cyInstance.container().addEventListener('mouseleave', () => {});
      }

      cyInstance.on('zoom pan render', () => {
        if (magnifierActive && window.lastMouse) updateMagnifierView(window.lastMouse.x, window.lastMouse.y);
      });
    }

    function setMagnifierZoom(val) {
      magZoom = parseFloat(val);
      magnifierZoomValue.textContent = magZoom.toFixed(1) + 'x';
      if (magnifierActive && window.lastMouse) {
        updateMagnifierView(window.lastMouse.x, window.lastMouse.y);
      }
    }
    magnifierZoomRange.addEventListener('input', e => setMagnifierZoom(e.target.value));
    setMagnifierZoom(magnifierZoomRange.value);








    // Main graph render
    function renderDriveAssistGraph(elements) {
      lastElements = elements;
      enrichNodesWithParentData(elements);
      const parentNodeIds = new Set();
      elements.forEach(el => {
        if (el.data && el.data.source && el.data.target) {
          parentNodeIds.add(el.data.source);
        }
      });
      let layoutType = hasAnyNodeWithPosition(elements) ? 'preset' : 'grid';
      var cy = cytoscape({
        container: document.getElementById('cy'),
        elements: elements.map(el => {
          if (el.data && el.position) {
            return {
              ...el,
              position: el.position,
              data: {
                ...el.data,
                position: el.position
              }
            };
          } else if (el.data && el.data.position) {
            return {
              ...el,
              position: el.data.position
            };
          } else {
            return el;
          }
        }),
        style: [
          {
            selector: 'node',
            style: {
              'background-height': '30px',
              'background-position-x': '100%',
              'background-position-y': '0%',
              'background-width': '30px',
              'height': 'data(height)',
              'label': 'data(label)',
              'offset-x': '12px',
              'offset-y': '-12px',
              'padding': '30px',
              'shape': 'round-rectangle',
              'text-valign': 'top',
              'text-halign': 'center',
              'text-min-width': '150px',
              'text-wrap': 'wrap',
              'text-max-width': 800,
              'width': '300px',
              'color': '#000',
              'font-weight': 'bold',
              'font-size': '80px'
            }
          },
          {
            selector: 'node.has-children',
            style: {
              'font-size': '80px',
              'text-wrap': 'wrap',
              'text-max-width': 800,

            }
          },
          {
            selector: 'node[originalType = "allocationtargetfunml"],node[type = "Bus"]', // tüm parent nodeleri
            style: {
                'border-width': 12,
                'background-height': '30px',
                'background-position-x': '100%',
                'background-position-y': '0%',
                'background-width': '30px',
                'height': 'data(height)',
                'label': 'data(label)',
                'text-margin-y': 120,
                'padding': '150px',
                'shape': 'round-rectangle',
                'text-valign': 'top',
                'text-halign': 'center',
                'text-min-width': '150px',
                'text-wrap': 'wrap',
                'text-max-width': 800,
                'width': '300px',
                'color': '#000',
                'font-weight': 'bold',
                'font-size': '120px'
            }
          },
          {
            selector: 'node[originalType = "logicalclusterfunml"],node[type = "Cluster"]',
            style: {
                'background-color': 'rgb(177, 195, 177)',
                'border-width': 6,
                'border-color': 'rgb(153, 141, 92)',
                'text-valign': 'center',
                'text-halign': 'center',
                'width': 'label',
                'text-wrap': 'wrap',
                'text-max-width': 800,
                'height': 'data(height)',
                'padding-left': '30px',
                'padding-right': '30px',
                'padding-top': '20px',
                'padding-bottom': '20px',
                'min-width': '100px',
                'min-height': '50px',
                'shape': 'round-rectangle',
                'font-size': '80px'
            }
          },
          {
            selector: 'node[originalType = "logicalsubcontextfunml"],node[type = "Subcontext"]',
            style: {
                'background-color': 'rgb(255, 204, 153)',
                'border-color': 'rgb(153, 121, 92)',
                'border-width': 6,
                'text-valign': 'center',
                'text-halign': 'center',
                'font-size': '80px',
                'width': 'label',
                'text-wrap': 'wrap',
                'text-max-width': 800,
                'height': 'data(height)',
                'padding-left': '30px',
                'padding-right': '30px',
                'padding-top': '20px',
                'padding-bottom': '20px',
                'min-width': '100px',
                'min-height': '50px',
                'shape': 'round-rectangle'
            }
          },
          {
            selector: 'node.node-search-highlight',
            style: {
              'border-color': '#1976d2',
              'border-width': 16,
              'box-shadow': '0 0 20px #1976d2',
              'background-color': '#e3f2fd',
              'z-index': 999
            }
          },
          {
            selector: 'edge',
            style: {
              'opacity': 0,
              'width': 10,
              'line-color': '#888',
              'line-style': 'dashed',
              'target-arrow-shape': 'chevron',
              'target-arrow-color': '#888',
              'arrow-fill': 'hollow',
              'line-scale': 0.5
            }
          },
          {
            selector: 'edge.highlighted',
            style: {
              'line-color': '#ff0000',
              'target-arrow-color': '#ff0000'
            }
          },
          {
            selector: 'node.highlight-l0',
            style: {
              'background-color': '#f52d05',
              'color': '#000',
              'text-wrap': 'wrap',
              'text-max-width': 800,
              'label': 'data(label)',
            }
          },
          {
            selector: 'node.highlight-l1',
            style: {
              'background-color': '#f57105',
              'color': '#000',
              'text-wrap': 'wrap',
              'text-max-width': 800,
              'label': 'data(label)'
            }
          },
          {
            selector: 'node.highlight-l2',
            style: {
              'background-color': '#f5c105',
              'color': '#000',
              'text-wrap': 'wrap',
              'text-max-width': 800,
              'label': 'data(label)'
            }
          },
          {
            selector: '.edge-highlight-l0',
            style: {
              'line-color': '#e60073',
              'target-arrow-color': '#e60073',
              'width': 18,
              'opacity': 1, // Bu satırı ekleyin
              'z-index': 10 // Bu satırı ekleyin
            }
          },
          {
            selector: '.edge-highlight-l1',
            style: {
              'line-color': '#ff9800',
              'target-arrow-color': '#ff9800',
              'width': 14,
              'opacity': 1, // Bu satırı ekleyin
              'z-index': 10 // Bu satırı ekleyin
            }
          },
          {
            selector: '.edge-highlight-l2',
            style: {
              'line-color': '#ffeb3b',
              'target-arrow-color': '#ffeb3b',
              'width': 10,
              'opacity': 1, // Bu satırı ekleyin
              'z-index': 10 // Bu satırı ekleyin
            }
          }

        ],
        layout: layoutType === 'preset' ? {
          name: 'preset',
          fit: true,
          padding: 50,
        } : {
            name: 'grid',
            fit: true, // grafiği sığdır
            padding: 100,
            avoidOverlap: true,
            rows: undefined, // otomatik rows/columns
            cols: undefined
        }
      });
      addCytoscapeMouseZoomFix(cy);
      parentNodeIds.forEach(function(parentId) {
        var node = cy.getElementById(parentId);
        if (node) node.addClass('has-children');
      });
      cy.ready(function () {
        cy.nodes().forEach(function (node) {
          if (node.data('originalType') === "allocationtargetfunml") {
            const size = getNodeSize(node);
            node.data('layout_x', node.position('x'));
            node.data('layout_y', node.position('y'));
            node.data('layout_width', size.width);
            node.data('layout_height', size.height);
          }
        });
        updateNodesWithParentDataLive();
      });
      cy.on('click', 'node', function (event) {
        var node = event.target;
        var nodeData = node.data();
        var nodeDataDiv = document.getElementById('node-data');
        nodeDataDiv.style.display = 'block';
        let parentInfoHtml = '';
        if (nodeData.parentInfo) {
          parentInfoHtml = `<hr><b>Parents Info:</b><br>` +
            Object.keys(nodeData.parentInfo)
              .map(k => `<b>${k}:</b> ${JSON.stringify(nodeData.parentInfo[k])}`)
              .join('<br>');
        }
        nodeDataDiv.innerHTML = `<strong>Node Data:</strong><br>` +
          Object.keys(nodeData).filter(k => k !== 'parentInfo').map(k => `<b>${k}:</b> ${JSON.stringify(nodeData[k])}`).join('<br>') +
          parentInfoHtml;
        cy.nodes().removeClass('highlight-l0 highlight-l1 highlight-l2');
        node.addClass('highlight-l0');
        var firstDegree = node.connectedEdges().connectedNodes().filter(n => n.id() !== node.id());
        firstDegree.addClass('highlight-l1');
        var secondDegree = cy.collection();
        firstDegree.forEach(function(n1) {
          n1.connectedEdges().connectedNodes().forEach(function(n2) {
            if (n2.id() !== node.id() && !firstDegree.contains(n2) && !n2.hasClass('highlight-l0')) {
              secondDegree = secondDegree.add(n2);
            }
          });
        });
        secondDegree.addClass('highlight-l2');

        // === EDGE HIGHLIGHT EKLENTİSİ ===
        cy.edges().removeClass('edge-highlight-l0 edge-highlight-l1 edge-highlight-l2');
        var edgesL0 = node.connectedEdges();
        edgesL0.addClass('edge-highlight-l0');
        var edgesL1 = cy.collection();
        firstDegree.forEach(function(n1){
          n1.connectedEdges().forEach(function(e){
            if (!edgesL0.contains(e)) {
              edgesL1 = edgesL1.add(e);
            }
          });
        });
        edgesL1.addClass('edge-highlight-l1');
        var edgesL2 = cy.collection();
        secondDegree.forEach(function(n2){
          n2.connectedEdges().forEach(function(e){
            if (!edgesL0.contains(e) && !edgesL1.contains(e)) {
              edgesL2 = edgesL2.add(e);
            }
          });
        });
        edgesL2.addClass('edge-highlight-l2');
      });

      
      cy.on('click', function (event) {
        if (event.target === cy) {
          cy.nodes().removeClass('highlight-l0 highlight-l1 highlight-l2');
          cy.edges().removeClass('edge-highlight-l0 edge-highlight-l1 edge-highlight-l2');
          document.getElementById('node-data').style.display = 'none';
        }
      });


      cy.on('cxttap', 'node', function (event) {
        event.originalEvent.preventDefault();
        contextNode = event.target;
        showContextMenu(event.originalEvent.clientX, event.originalEvent.clientY);
      });
      cy.on('tap', function (event) {
        if (event.target === cy) {
          hideContextMenu();
        }
      });
      document.addEventListener('click', function(e) {
        if (!e.target.closest('#context-menu')) {
          hideContextMenu();
        }
      });
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          hideContextMenu();
          hideFullscreenPanel();
        }
      });
      if (layoutType === 'preset') {
        let nodesWithoutPos = cy.nodes().filter(n => typeof n.position('x') !== "number" || typeof n.position('y') !== "number" || isNaN(n.position('x')) || isNaN(n.position('y')));
        if (nodesWithoutPos.length > 0) {
          nodesWithoutPos.layout({
            name: 'grid',
            fit: true, // grafiği sığdır
            padding: 100,
            avoidOverlap: true,
            rows: undefined, // otomatik rows/columns
            cols: undefined
          }).run();
        }
      }
      cyInstance = cy;
      attachMagnifierEvents();
      setupEdgeHighlightEvents(); // Bu satırı ekleyin
      cyInstance.on('dragfree', function(e) {
      });
    }

    




    function highlightSearchResults(searchTerm) {
      if (!cyInstance) return;
      cyInstance.nodes().removeClass('node-search-highlight');
      if (!searchTerm || searchTerm.trim() === "") return;

      const term = searchTerm.trim().toLowerCase();

      cyInstance.nodes().forEach(node => {
        const data = node.data();
        for (const key in data) {
          if (
            typeof data[key] === "string" &&
            data[key].toLowerCase().includes(term)
          ) {
            node.addClass('node-search-highlight');
            break;
          } else if (
            typeof data[key] === "number" &&
            data[key].toString().includes(term)
          ) {
            node.addClass('node-search-highlight');
            break;
          }
        }
      });
    }

    // Event listener
    document.getElementById('searchBox').addEventListener('input', function(e) {
      highlightSearchResults(e.target.value);
    });







    function showContextMenu(x, y) {
      const menu = document.getElementById('context-menu'); // alles from Baran Layout
      menu.style.display = 'block';
      const maxX = window.innerWidth - menu.offsetWidth - 8;
      const maxY = window.innerHeight - menu.offsetHeight - 8;
      menu.style.left = Math.min(x, maxX) + 'px';
      menu.style.top = Math.min(y, maxY) + 'px';
    }
    function hideContextMenu() {
      document.getElementById('context-menu').style.display = 'none';
    }

    function showFullscreenPanel(contentHtml) {
      document.getElementById('fullscreen-content').innerHTML = contentHtml;
      document.getElementById('fullscreen-panel').style.display = 'block';
    }
    function hideFullscreenPanel() {
      document.getElementById('fullscreen-panel').style.display = 'none';
    }
    document.getElementById('fullscreen-close').addEventListener('click', hideFullscreenPanel);

    document.getElementById('context-more').addEventListener('click', function() {
      hideContextMenu();
      if (contextNode) {
        const node = contextNode;
        const cy = cyInstance;
        const firstDegree = node.connectedEdges().connectedNodes().filter(n => n.id() !== node.id());
        let secondDegree = cy.collection();
        firstDegree.forEach(function(n1) {
          n1.connectedEdges().connectedNodes().forEach(function(n2) {
            if (n2.id() !== node.id() && !firstDegree.contains(n2) && !n2.hasClass('highlight-l0')) {
              secondDegree = secondDegree.add(n2);
            }
          });
        });
        const showNodes = cy.collection([node]).union(firstDegree).union(secondDegree);
        const showNodeIds = showNodes.map(n => n.id());
        const showEdges = cy.edges().filter(edge =>
          showNodeIds.includes(edge.source().id()) && showNodeIds.includes(edge.target().id())
        );
        function serializeNode(n) {
          const data = JSON.parse(JSON.stringify(n.data()));
          const pos = n.position();
          return { data, position: { x: pos.x, y: pos.y } };
        }
        function serializeEdge(e) {
          return { data: JSON.parse(JSON.stringify(e.data())) };
        }
        const miniElements = [
          ...showNodes.map(serializeNode),
          ...showEdges.map(serializeEdge)
        ];
        let html = `<h2>Ausgewählte Nodes</h2>
          <div id="mini-cy" style="width:180%; max-width:1600px; height:600px; border:1px solid #aaa; margin:auto;"></div>`;
        showFullscreenPanel(html);
        setTimeout(() => {
          let miniCy = cytoscape({
            container: document.getElementById('mini-cy'),
            elements: miniElements,
            style: cyInstance.style().json(),
            layout: {
              name: 'preset',
              fit: true,
              padding: 30
            }
          });
        }, 10);
      }
    });


    
    document.getElementById('moveMostConnectedBtn').addEventListener('click', () => {
      if (!cyInstance) return;
      const mostConnectedNode = findMostConnectedNode(cyInstance);
      if (!mostConnectedNode) return;
      const parentId = mostConnectedNode.data('parent');
      if (!parentId) return;
      const parentNode = cyInstance.getElementById(parentId);
      const childNodes = cyInstance.nodes().filter(n => n.data('parent') === parentId).toArray();

      const groupNodes = [parentNode, ...childNodes];

      // Sensor ve Actuator node'larının tüm x'lerini al
      const actuatorNodes = cyInstance.nodes().toArray().filter(n => n.data('componenttype') === 'Actuator');
      const sensorNodes = cyInstance.nodes().toArray().filter(n => n.data('componenttype') === 'Sensor');
      const allXs = actuatorNodes.concat(sensorNodes).map(n => n.position('x'));

      let centerX = 0;
      if (allXs.length) {
        const minX = Math.min(...allXs);
        const maxX = Math.max(...allXs);
        centerX = (minX + maxX) / 2;
      }

      let y = 50;
      const CHILD_PADDING = 150;

      // Grup node'larının toplam genişliğini hesapla
      let totalWidth = 0;
      groupNodes.forEach((node, i) => {
        const size = getNodeSize(node);
        totalWidth += size.width;
        if (i < groupNodes.length - 1) {
          totalWidth += CHILD_PADDING * 4;
        }
      });

      // İlk node'un x pozisyonu: referans ortası - grubun yarı genişliği
      let startX = centerX - totalWidth / 2;

      groupNodes.forEach((node, i) => {
        const size = getNodeSize(node);
        node.position({
          x: startX + size.width / 2,
          y: y + size.height / 2
        });
        startX += size.width + CHILD_PADDING * 4;
      });

      cyInstance.fit(groupNodes, 100);
    });




// JSON dosyası yükleme event listener'ı - DÜZELTME
document.getElementById('jsonFileInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const json = JSON.parse(ev.target.result);
      const elements = parseDriveAssistData(json); // Bu satır eksikti
      renderDriveAssistGraph(elements); // Bu satır eksikti
      
      // Cytoscape oluşturulduktan sonra çerçeve event listener'larını ekle
      setTimeout(() => {
        setupFrameEventListeners(); // Bu satırı ekleyin
        setupEdgeHighlightEvents(); // Bu satırı ekleyin
      }, 100);



    } catch (err) {
      // Hem JS hatası hem de browser'ın verdiği hata mesajı
      showErrorPanel("Hatalı veri: " + err.message);
    }
  };
  reader.onerror = function(ev) {
    // Browser hata mesajı
    showErrorPanel("Dosya okunamadı: " + reader.error.message);
  };
  reader.readAsText(file);
});

    document.getElementById('exportBtn').addEventListener('click', function() {
        if (!cyInstance) {
            showErrorPanel('Öfnnen Sie bitte eine JSON-Datei.');
            return;
        }
        updateNodesWithParentDataLive();
        const nodes = cyInstance.nodes().map(node => {
            const data = {...node.data()};
            data.position = node.position();
            if (node.data('originalType') === "allocationtargetfunml") {
            const size = getNodeSize(node);
            data.layout_x = node.data('layout_x');
            data.layout_y = node.data('layout_y');
            data.layout_width = node.data('layout_width');
            data.layout_height = node.data('layout_height');
            }
            if (node.data('parentInfo')) {
            const parentInfo = {...node.data('parentInfo')};
            if (typeof parentInfo.componenttype === "undefined") {
                delete parentInfo.componenttype;
            }
            data.parentInfo = parentInfo;
            }
            return { data };
        });
        const edges = cyInstance.edges().map(edge => ({
            data: {...edge.data()}
        }));
        const exportObj = {
            elements: {
            nodes: nodes,
            edges: edges
            }
        };
        const exportData = JSON.stringify(exportObj, null, 2);
        const blob = new Blob([exportData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');

        // === Tarihli dosya adı için eklenen kod ===
        const now = new Date();
        const pad = n => n.toString().padStart(2, '0');
        const fileName = `Baran_Layout_${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}.json`;
        // ==========================================

        a.href = url;
        a.download = fileName; // Burada dinamik dosya adını kullandık
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        });

    document.getElementById('customLayoutBtn').onclick = function() {
      if (!cyInstance) {
        showErrorPanel('Bitte erst eine JSON Datei hochladen!');
        return;
      }
      applyCustomLayoutForAllocationTargets(cyInstance);
      applyCustomLayoutForAllocationTargets(cyInstance);
      cyInstance.nodes().forEach(function (node) {
        if (node.data('originalType') === "allocationtargetfunml") {
          const size = getNodeSize(node);
          node.data('layout_x', node.position('x'));
          node.data('layout_y', node.position('y'));
          node.data('layout_width', size.width);
          node.data('layout_height', size.height);
        }
      });
      setTimeout(() => {
        updateGroupFrames();
      }, 500);
      updateNodesWithParentDataLive();
          // Layout sonrası çerçeveleri güncelle

    }
















// === ÇERÇEVE SİSTEMİ JavaScript KODLARI ===

// Çerçeve durumu ve yönetimi
let framesVisible = false;
let frameNodes = [];

// Grup çerçevelerini oluştur
function createGroupFrames() {
  if (!cyInstance) return;
  
  // Önceki çerçeveleri temizle
  removeGroupFrames();
  
  const groups = [
    {
      name: 'Sensor',
      type: 'Sensor',
      className: 'sensor-frame',
      color: '#f44336'
    },
    {
      name: 'ECU/Zusammenbau',
      type: ['ECU', 'Zusammenbau'],
      className: 'ecu-frame',
      color: '#2196f3'
    },
    {
      name: 'Actuator',
      type: 'Actuator',
      className: 'actuator-frame',
      color: '#ff9800'
    }
  ];

  groups.forEach((group, index) => {
    const groupNodes = getGroupNodes(group.type);
    if (groupNodes.length > 0) {
      const bounds = calculateGroupBounds(groupNodes);
      if (bounds) {
        createFrameForGroup(group, bounds, index);
      }
    }
  });
}

// Grup node'larını getir
function getGroupNodes(componentTypes) {
  if (!cyInstance) return [];
  
  const types = Array.isArray(componentTypes) ? componentTypes : [componentTypes];
  const groupNodes = [];
  
  // Parent node'ları bul
  const parentNodes = cyInstance.nodes().filter(n => 
    n.data('originalType') === "allocationtargetfunml" &&
    types.includes(n.data('componenttype'))
  );
  
  // Parent'ları ekle
  parentNodes.forEach(parent => {
    groupNodes.push(parent);
    
    // Child'ları da ekle
    const children = cyInstance.nodes().filter(n => 
      n.data('parent') === parent.id()
    );
    children.forEach(child => groupNodes.push(child));
  });
  
  return groupNodes;
}

// Grup sınırlarını hesapla
function calculateGroupBounds(nodes) {
  if (nodes.length === 0) return null;
  
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  
  nodes.forEach(node => {
    const pos = node.position();
    const bb = node.boundingBox();
    
    minX = Math.min(minX, bb.x1);
    maxX = Math.max(maxX, bb.x2);
    minY = Math.min(minY, bb.y1);
    maxY = Math.max(maxY, bb.y2);
  });
  
  // Padding ekle
  const padding = 100;
  return {
    x: minX - padding,
    y: minY - padding,
    width: maxX - minX + (2 * padding),
    height: maxY - minY + (2 * padding)
  };
}

// Grup için çerçeve oluştur
function createFrameForGroup(group, bounds, index) {
  if (!cyInstance) return;
  
  const frameId = `frame-${index}`;
  const closeId = `frame-close-${index}`;
  
  // Ana çerçeve node'u
  const frameNode = {
    data: {
      id: frameId,
      label: group.name,
      isFrame: true,
      groupType: group.name
    },
    position: {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    },
    classes: `group-frame ${group.className}`,
    selectable: false,
    grabbable: false
  };
  

  
  // Node eklendikten sonra inline stil ekleyin:
  cyInstance.add([frameNode]);
  frameNodes.push(frameId, closeId);

  // Çerçeve boyutunu ve stilini ayarla
  // Çerçeve boyutunu ve stilini ayarla (createFrameForGroup fonksiyonunda)
  const frameElement = cyInstance.getElementById(frameId);
  frameElement.style({
    'width': bounds.width,
    'height': bounds.height,
    'background-opacity': 0, // Tamamen şeffaf
    'background-color': 'transparent', // Bu satırı ekleyin
    'border-opacity': 0.8,   // Sadece kenarlık görünür
    'text-margin-y': -30,    // Yazıyı daha yukarı kaydır
    'font-size': '500px',     // Yazı boyutu
    'z-index': -1
  });
}

// Çerçeveleri kaldır
function removeGroupFrames() {
  if (!cyInstance) return;
  
  frameNodes.forEach(nodeId => {
    const node = cyInstance.getElementById(nodeId);
    if (node.length > 0) {
      cyInstance.remove(node);
    }
  });
  frameNodes = [];
}

// Çerçeveleri güncelle
function updateGroupFrames() {
  if (framesVisible) {
    createGroupFrames();
  }
}

// Çerçeve toggle fonksiyonu
function toggleFrames() {
  framesVisible = !framesVisible;
  
  if (framesVisible) {
    createGroupFrames();
  } else {
    removeGroupFrames();
  }
  
  // Buton metnini güncelle
  const btn = document.getElementById('frameToggleBtn');
  btn.textContent = framesVisible ? 'Rahmen Aus' : 'Rahmen Ein';
}


// === EVENT LISTENER'LAR ===

// Çerçeve toggle butonu event listener'ı
document.getElementById('frameToggleBtn').addEventListener('click', toggleFrames);




// Layout değişikliklerinde çerçeveleri güncelle
cyInstance.on('layoutstop', updateGroupFrames);
cyInstance.on('position', 'node', function(evt) {
  if (!evt.target.data('isFrame') && !evt.target.data('isFrameClose')) {
    // Sadece normal node'lar hareket ettiğinde güncelle
    setTimeout(updateGroupFrames, 100);
  }
});


// Cytoscape event listener'ları - cyInstance oluşturulduktan sonra eklenecek
if (cyInstance) {

  
  // Layout değişikliklerinde çerçeveleri güncelle
  cyInstance.on('layoutstop', updateGroupFrames);
  
  // Node pozisyon değişikliklerinde çerçeveleri güncelle
  cyInstance.on('position', 'node', function(evt) {
    if (!evt.target.data('isFrame') && !evt.target.data('isFrameClose')) {
      // Sadece normal node'lar hareket ettiğinde güncelle
      setTimeout(updateGroupFrames, 100);
    }
  });
}




  </script>
</body>
</html>